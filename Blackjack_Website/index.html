
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Starter Template for Bootstrap</title>

    <!-- Bootstrap core CSS -->
    <link href="dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <!-- <link href="../../assets/css/ie10-viewport-bug-workaround.css" rel="stylesheet"> -->

    <!-- Custom styles for this template -->
    <link href="starter-template.css" rel="stylesheet">

    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    <!-- <script src="../../assets/js/ie-emulation-modes-warning.js"></script> -->

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">BlackJack with Monte Carlo</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="#">Home</a></li>
            <li><a href="#intro">Introduction</a></li>
            <li><a href="#rules">Rules</a></li>
            <li><a href="#obj">Project Objective</a></li>
            <li><a href="#design">High-level design</a></li>
            <li><a href="#programdesign">Game Play</a></li>
            <li><a href="#result">Results</a></li>
            <li><a href="#conclusion & future work">Conclusions & Future Work</a></li>
            <li><a href="#appendix">Appendix</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
      <div class="starter-template">
        <h1>BlackJack with Monte Carlo</h1>
        <p class="lead">ECE5760 Final Project<br>A Project By Ming He (hh759), Nikhil Pillai (ns594), Joash Shankar (jcs556)</p>
      </div>
      <hr>
      <div class="center-block">
          <iframe width="640" height="360" src="https://youtube.com/embed/zh-qvZSGmkQ?si=v5zsrun2a8n5aBFw" frameborder="0" allowfullscreen></iframe>
          <h4 style="text-align:center;">Demonstration Video</h4>
      </div>

      <hr id="intro">
      <div>
            <h2 style="text-align:left; padding: 0px 26px;">Introduction</h2>
            <p style="text-align: left;padding: 0px 30px;">
                This Blackjack with Monte Carlo project seamlessly combines the excitement of a classic card game with the analytical power of Monte Carlo simulations for a more enriching user experience. In this project, players are immersed in Blackjack while receiving real-time probabilistic insights generated by millions of simulations. The game is displayed on a 640x480 VGA screen connected to an FPGA, where each visual element is rendered to enhance interactivity and clarity. At its core, the project employs Monte Carlo methods to simulate millions of potential game outcomes, providing players with data-driven advice to inform their decisions. By mapping each card and player action to a set of probable results, the system calculates winning and tie probabilities, as well as the player’s most likely next card value, helping players make better decisions.
            </p>
      </div>
      <hr id="rules">
      <div>
            <h2 style="text-align:left; padding: 0px 26px;">Rules</h2>
            <p style="text-align: left;padding: 0px 30px;">
                BlackJack is a card game against a dealer. At the start of a round, each player (in our case, 1-4 players) is dealt 2 cards. The dealer is also dealt two cards, but the dealer’s top card is hidden from the player(s) until they are each done with their turn(s). The goal of the game is to get the value of your hand of cards as close to 21 as possible, without crossing 21, and to be larger than the value of the dealer's hands. The value of each card is listed below:
                <ul style="text-align: left;padding: 0px 50px;">
                    <li>10/Jack/Queen/King → 10</li>
                    <li>2 through 9 → same value as the card</li>
                    <li>Ace → 1 or 11 (player's choice)</li>
                </ul>
            </p>
            <p style="text-align: left;padding: 0px 30px;">
                <br>
                If the player has less than 21, they can choose to “hit” and receive a random card from the deck. They can also choose to “stand” and keep the cards they have. If the player exceeds 21, they “bust” and automatically lose the round. If the player scores exactly 21 with their initial hand, they hit Blackjack. If the dealer does not also hit Blackjack initially, the player automatically wins. However, if the dealer does hit Blackjack with the initially dealt two cards, the game results in a tie between the player and the dealer. Otherwise, the player wins if they are closer to 21 and larger than the value of the dealer's hands, or the player wins if the player has a value that is less than 21 and the dealer busts.
                <br>
                <br>
                In this project, each player starts with $1000 where each player can place a minimum bet of $3 and a maximum bet of $1000.
            </p>
      </div>
    <hr id='obj'>  
          <h2 style="text-align:left; padding: 0px 26px;">Project Objective:</h2>
          <p style="text-align: left;padding: 0px 30px;">    
             This project aimed to design and implement Monte Carlo algorithms to simulate the game of Blackjack on a DE1-SoC board. This version offers users a general understanding of win, tie, and loss probabilities based on the initial hands and dealer's hands. Additionally, it includes a card counting feature that predicts the next potential card and its probability. In total, it provides five cards with ascending probabilities, assisting players in making better decisions on whether to hit or stand.  
          </p>
    <div class="row" style="text-align:center;">
        <style>
            .image-container_home {
                width: 50vw; /* Adjust the width as needed */
                height: 25vw; /* Adjust the height as needed */
                overflow: hidden; /* Hide parts of the image outside the container */
                margin: auto; /* Center the container */
                display: block; /* Ensure the container is a block-level element */
            }

            .image-container_home img {
                width: 100%;
                height: 100%;
                object-fit: cover; /* Resize the image to cover the container */
                object-position: 40% 35%; /* Center the image within the container */
            }
        </style>
        <div class="image-container_home" style="text-align:center;">
            <img src="pics/home_screen.jpg" alt="Home screen">
            <h4 style="margin-top: 0; margin-bottom: 10px;">Home Screen</h4>
        </div>
    </div>

    <hr id='design'>
        <div>
            <h2 style="text-align:left; padding: 0px 26px;">High-level Design</h2>
            <h4 style="text-align: left;padding: 0px 30px;">Random Number Generation</h4>
            <p style="text-align: left;padding: 0px 30px;">
                An important component of the blackjack game is the random number generation for selecting cards. Random number generation on the HPS occurs through a simple rand() call; however, the random number generation for each simulation in Verilog must occur through a custom-built random number generator. 
                <br>
                <br>
                The first approach taken under this premise was the implementation of an LFSR (Linear Feedback Shift Register). The LFSR periodically generates random values of a specified bit width based on tap placement. Built off of the same principle as a standard shift register, the LFSR shifts all bits by one and replaces the first bit based on tap logic. The tap logic for an LFSR varies for different bit widths based on pseudo-random polynomials. Different polynomial expressions exist for varying bit widths, which determine what bits will be tapped. All bits to be tapped are XOR’d with each other and assigned as the first bit. In this way, it is only the first bit in an LFSR that is truly random while the remaining are periodically predictable. 
                <br>
                <br>
                One of an LFSR's major properties is its periodicity. As such for a given seed, the sequences of values are wholly predictable. Changing the seed only changes the periodic progression's start point, indicating the lack of true randomness between consecutive or parallel simulations. However, this periodic nature guarantees that the same number never occurs consecutively. 
                <br>
                <br>
                To generate truly random numbers, the project utilizes multiple parallel LFSRs and concatenates their respective first bits. Since the first bits of each LFSR are the only bits that are truly random, a concatenation of all these bits guarantees a truly random number for different seeds. Consecutive random numbers do not explicitly follow the same random number sequence, introducing greater variation in the values generated. However, a drawback of this approach was the potential generation of two consecutive numbers that may be equivalent. This approach's trade-off was greater randomness in the sacrifice of true uniqueness. The project favored greater randomization since guaranteeing true uniqueness simply involved instituting another module that tracks if the value was already generated, and in situations, where values were already generated, the output random generator would simply be invoked again. 
                <br>
                <br>
                The primary role of the output random generator within the project is to generate random indices as each card is stored within a particular index of the On-Chip SRAM. As such, generating a random index consequently leads to selecting a random card. 
            </p>

            <h4 style="text-align: left;padding: 0px 30px;">Platform Designer Connections</h4>
            <p style="text-align: left;padding: 0px 30px;">
                In Platform Designer, we create several OnChip SRAM and Parallel Input/Output (PIO) blocks that create an interface that the ARM processor can access. It's also important to note that PIO blocks are memory-mapped, so they are assigned specific addresses in the lightweight axis master, each with an offset for the lightweight axis master's base address. The OnChip SRAM blocks are assigned specific addresses in the heavy axis master, each with an offset for the heavy axis master's base address. The layout of this can be seen in the figure below:
            </p>
            <style>
                .image-container_PIOs {
                    width: 43vw; /* Adjust the width as needed */
                    height: 22vw; /* Adjust the height as needed */
                    margin: auto; /* Center the container */
                    display: block; /* Ensure the container is a block-level element */
                }

                .image-container_PIOs img {
                    width: 100%;
                    height: 100%;
                    object-fit: cover; /* Resize the image to cover the container */
                    object-position: 40% 35%; /* Center the image within the container */
                }
            </style>
            <br>
            <div class="image-container_PIOs" style="text-align:center;">
                <img src="pics/pio1.PNG" alt="Platform Designer Connections Setup 1">
            </div>
            <br>
            <div class="image-container_PIOs" style="text-align:center;">
                <img src="pics/pio2.PNG" alt="Platform Designer Connections Setup 2">
            </div>
            <br>
            <div class="image-container_PIOs" style="text-align:center;">
                <img src="pics/pio3.PNG" alt="Platform Designer Connections Setup 3">
            </div>
            <br>
            <div class="image-container_PIOs" style="text-align:center;">
                <img src="pics/pio4.PNG" alt="Platform Designer Connections Setup 4">
            </div>
            <br>
            <div class="image-container_PIOs" style="text-align:center;">
                <img src="pics/pio5.PNG" alt="Platform Designer Connections Setup 5">
            </div>
            <br>
            <br>
            <table border="1" style="width: 100%; border-collapse: collapse; text-align: left;">
                <thead>
                    <tr>
                        <th style="width: 25%;">PIO block / pointer</th>
                        <th>Function</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><i>player_init_hand / player_init_hand_ptr</i></td>
                        <td>Store initial hand value of the player(s) when the game starts</td>
                    </tr>
                    <tr>
                        <td><i>dealer_top / dealer_top_ptr</i></td>
                        <td>Stores value of dealer's shown card</td>
                    </tr>
                    <tr>
                        <td><i>init_done / init_done_ptr</i></td>
                        <td>Acts as a flag to indicate that the two on-chip memories have been completely filled</td>
                    </tr>
                    <tr>
                        <td><i>num_wins / num_wins_ptr</i></td>
                        <td>Holds the number of wins recorded by the FPGA during simulations</td>
                    </tr>
                    <tr>
                        <td><i>num_ties / num_ties_ptr</i></td>
                        <td>Holds the number of ties recorded by the FPGA during simulations</td>
                    </tr>
                    <tr>
                        <td><i>card_one, card_two, … card_ten / card_n_ptr</i></td>
                        <td>Holds the count/value associated with the “nth” card value in the simulations (to help with “card counting”)</td>
                    </tr>
                    <tr>
                        <td><i>finish_simuls / simul_complete_ptr</i></td>
                        <td>Acts as a flag to indicate all the simulations are complete</td>
                    </tr>
                    <tr>
                        <td><i>mem_start_point / mem_starting_ptr</i></td>
                        <td>Indicates the starting address in the on-chip memory where the five decks of cards are stored, and this address changes as cards are drawn from the decks</td>
                    </tr>
                </tbody>
            </table>
            
            <br>
            <br>
            <table border="1" style="width: 100%; border-collapse: collapse; text-align: left;">
                <thead>
                    <tr>
                        <th style="width: 20%;">OnChip SRAM block</th>
                        <th style="width: 15%;">Size</th>
                        <th>Purpose</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><i>Onchip_SRAM_cards</i></td>
                        <td>1248 bytes</td>
                        <td>This on-chip SRAM stores the values associated with each card in the total deck used. The first few slots are zeroed to indicate changing deck sizes after cards are dealt to all players initially and after each player is done with their turn.</td>
                    </tr>
                    <tr>
                        <td><i>Onchip_SRAM_seed</i></td>
                        <td>10000 bytes</td>
                        <td>This on-chip SRAM stores all the random seeds necessary for the random number generators in each parallel block on the FPGA. Each parallel block needs 4 different random seeds and as such under 60 simulations, a total of 240 random seeds are necessary. Each seed is a 32-bit (4-byte) value. This on-chip SRAM has significantly more storage than required to provide greater flexibility in seeding for future implementations.</td>
                    </tr>
                </tbody>
            </table>


        <h4 style="text-align: left;padding: 0px 30px;">Blackjack State Machine</h4>
            <p style="text-align: left;padding: 0px 30px;">
                The state machine, inspired by the commonly known basic strategy for Blackjack, operates within a generate block that includes 60 parallel simulations and consists of 13 states:    
            </p>

            <style>
                table {
                  width: 100%;
                  border-collapse: collapse;
                  table-layout: fixed; /* This can help prevent overly wide tables */
                }
              
                th, td {
                  border: 1px solid #ddd;
                  padding: 10px; /* Add more padding for a better look */
                  text-align: left;
                  word-wrap: break-word; /* Ensures text wraps to avoid stretching the cell too wide */
                }
              
                th {
                  background-color: #f4f4f4;
                  font-weight: bold;
                }
              
                tr:nth-child(even) {
                  background-color: #f9f9f9; /* Zebra striping for rows */
                }
            </style>

<table border="1" style="width: 100%; border-collapse: collapse; text-align: left;">
    <thead>
        <tr>
            <th style="width: 20%;">State Name</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>State 0</td>
            <td>Check if two of the on-chip memories are filled, and then copy the memory block that stores all the card values into 60 M10K memory blocks inside the generate block</td>
        </tr>
        <tr>
            <td>State 1</td>
            <td>Fetch a card value from a random address in the M10K memory block, and record the card selected to avoid repetition in card picking</td>
        </tr>
        <tr>
            <td>State 2</td>
            <td>Implement a buffer state to ensure values from the M10K memory block can be read, addressing the issue of an inferred latch</td>
        </tr>
        <tr>
            <td>State 3</td>
            <td>Receive the card value, which corresponds to the hidden card in the dealer's initial hand</td>
        </tr>
        <tr>
            <td>State 4</td>
            <td>Check if the dealer has hit Blackjack; if so, jump directly to State 10 to demonstrate the result</td>
        </tr>
        <tr>
            <td>State 5</td>
            <td>Fetch a card value for the player from a random address in the M10K memory block that has not been visited before, and record the selected card to prevent repetition in card picking</td>
        </tr>
        <tr>
            <td>State 6</td>
            <td>Implement a buffer state to ensure values from the M10K memory block can be read, addressing the issue of an inferred latch</td>
        </tr>
        <tr>
            <td>State 7</td>
            <td>This state gets the next potential card value that could be dealt to the player. Consequently, the card counting register begins recording the card value to inform the next hitting decision. In addition, according to the basic Blackjack strategy, based on the player's hand and the dealer's top card, which is sent from the HPS via PIO, return to State 5 to draw cards for the player if necessary, until the conditions are met</td>
        </tr>
        <tr>
            <td>State 8</td>
            <td>Fetch a card value for the dealer from a random address in the M10K memory block that has not been visited before, and record the selected card to prevent repetition in card picking</td>
        </tr>
        <tr>
            <td>State 9</td>
            <td>Implement a buffer state to ensure values from the M10K memory block can be read, addressing the issue of an inferred latch</td>
        </tr>
        <tr>
            <td>State 10</td>
            <td>Continue fetching card values by returning to State 8 to fetch a value from random addresses in the M10K memory block that have not been visited before. Record each selected card to prevent repetition in card picking. Continue calculating the dealer's hand until the dealer's score reaches 17 or higher</td>
        </tr>
        <tr>
            <td>State 11</td>
            <td>Check the result and record whether the player wins or ties with the dealer. Then, activate the game completion signal for later result counting</td>
        </tr>
        <tr>
            <td>State 12</td>
            <td>Implement a buffer state that makes sure another always block to accumulate the results before clearing the registers for starting the next round of game simulation</td>
        </tr>
        <tr>
            <td>State 13</td>
            <td>To conserve hardware resources, clear the registers used in the simulations within the generate block, and then return to State 1. This process repeats 100 times</td>
        </tr>
    </tbody>
</table>

                <h4 style="text-align: left;padding: 0px 30px;">Win & Tie Probability Computation</h4>
                <p style="text-align: left;padding: 0px 30px;">
                    On the Verilog side, since each parallel generates block runs 100 simulations internally, each generates tracks its wins internally. Upon each parallel block completing its internal simulations, the wins are incremented based on each player's result. Once all internal simulations are accounted for each parallel block, a flag is set across all parallel blocks, indicating readiness for the final result count. A similar procedure is followed for ties as well.
                    <br>
                    <br>
                    The final result counts are accounted for in a separate clocked module. Within this module, the logic runs through all accumulated results sequentially, incrementing the total number of wins and ties through all parallel blocks. These counts are then communicated to the HPS over the PIO ports highlighted in the Platform Designer Connections section. 
                    <br>
                    <br>
                    On the HPS, the probabilities are calculated in floating point by dividing the net win/tie counts by the total number of simulations. These probabilities are then scaled to be percentages with each percentage recalculated every full simulation. 
                </p>
                <h4 style="text-align: left;padding: 0px 30px;">Card Probability</h4>
                <p style="text-align: left;padding: 0px 30px;">
                    Inside state 7 of the state machine, the next potential player card value is received from the M10K memory block and recorded. Based on this card value, a case statement within each simulation increments the corresponding register. When the simulation finishes, indicated by the simulation complete signal in state 11, the number is recorded. Eventually, all possible 10 card values from all simulations (6000 in our case) are sent to the HPS via PIO for probability calculation
                    <br>
                    <br>
                    Given that only the top 5 likely cards are displayed to the user, these card probabilities are sorted after each simulation in ascending order through the QSort algorithm for efficiency. After sorting the card probability results, the top 5 highest counts are stored and displayed to be the 5 cards with the highest likelihood of appearing given a hit command is executed. 
                </p>
                <h4 style="text-align: left;padding: 0px 30px;">Data Flow - HPS + Verilog Integration</h4>
                <p style="text-align: left;padding: 0px 30px;">
                    Given the presence of multiple internal simulations with each of Verilog's parallel blocks, it became pertinent to incorporate a synchronization methodology. The alternative involves the HPS enforcing a delay to account for the execution time of the FPGA, though the time for the delay would at best be a guess. The synchronization, on the other hand, enables immediate execution of HPS logic and maximizes speed by reducing wait times.
                    <br>
                    <br>
                    An important aspect of the project is data transfer, both seed and card values. These are both shared between ARM and Verilog through On-Chip SRAMs.
                    <br>
                    <br>
                    Since each parallel block holds its own M10k block to access and use during simulations, the main Card Value On-Chip SRAM values are distributed in parallel within external clocked logic. All parallel blocks do not begin until the distribution of these card values are accounted for and their individual M10k blocks are filled.               
                </p>

                <div class="image-container" style="text-align:center;">
                    <img src="pics/simulation_max_count_explanation.png" alt="verilog HPS integration">
                </div>
                <h4 style="text-align: left;padding: 0px 30px;">Simulation Count Maximization</h4>
                <p style="text-align: left;padding: 0px 30px;">
                    The FPGA runs approximately 6000 simulations. However, to attain more simulations and leverage the Monte Carlo effect of probability convergence after multiple simulations, additional simulations are invoked within the HPS. If 6000 simulations that run on the FPGA are considered one block, the ARM executes 2000 blocks per hand or hit to attain the final probabilities displayed to the user. In other words, the total number of simulations run is 12,000,000 simulations with a total compute time of approximately 3.25 seconds. This timing delay is acceptable in this situation given the interactive nature of the game as there exist no time-constrained tasks on decision within the game. 
                </p>
                
        </div>
    <hr id='programdesign'>
        <div>
            <h2 style="text-align:left; padding: 0px 26px;">Gameplay</h2>

            <h4 style="text-align: left;padding: 0px 30px;">Graphics</h4>
            <p style="text-align: left;padding: 0px 30px;">
                The graphics of this game are geared towards using a VGA display connected to the FPGA.
                The FPGA's memory-mapped I/O is used to control the VGA display (vga_char_ptr allows the program to write text to the screen and vga_pixel_ptr allows the program to draw shapes and colors directly). 
                We make use of several drawing functions to create different elements on the VGA screen:
            </p>
            <!-- <div class="image-container" style="text-align:center;">
                <img src="pics/game_flow_functions.png" alt="functions and explanations">
            </div> -->

            <table border="1" style="width: 100%; border-collapse: collapse; text-align: left;">
                <thead>
                    <tr>
                        <th style="width: 30%;">Drawing Functions</th>
                        <th>Purpose</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><i>VGA_text()</i></td>
                        <td>Display string of text</td>
                    </tr>
                    <tr>
                        <td><i>VGA_text_clear() / Game_text_clear()</i></td>
                        <td>Clear text from entire screen / Clear a specific section of text</td>
                    </tr>
                    <tr>
                        <td><i>VGA_box() / VGA_disc()</i></td>
                        <td>Draw a filled in rectangle / Draw a filled in circle</td>
                    </tr>
                    <tr>
                        <td><i>draw_card()</i></td>
                        <td>Draws a playing card at set coordinates with the given value and suit</td>
                    </tr>
                    <tr>
                        <td><i>display_card()</i></td>
                        <td>Displays cards for a specific player at their designated position and also tracks card indices</td>
                    </tr>
                    <tr>
                        <td><i>display_dealer_card()</i></td>
                        <td>Displays cards for the dealer at their designated position</td>
                    </tr>
                    <tr>
                        <td><i>display_result()</i></td>
                        <td>Displays the result of the game for a specific player, including whether they won, lost, busted, or tied, and their bet amount</td>
                    </tr>
                </tbody>
            </table>
            

            <h4 style="text-align: left;padding: 0px 30px;">Game Flow</h4>
            <ul style="text-align: left;padding: 0px 50px;">
                <li><i>Main Menu:</i> The game starts with a main menu displayed on the VGA screen, which shows the title, a brief description of the rules, and prompts to move onto the game screen</li> 
                <li><i>Gameplay Initialization:</i> The game initializes by setting up the default screen and prompts the user to enter the number of players</li> 
                <li><i>Betting Phase:</i> Players are prompted to enter their bet amounts</li>
                <li><i>Card Dealing and Game Play:</i> The game deals initial cards to the players and the dealer; Players can choose to hit or stand, with their choices displayed and updated on the VGA screen</li>
                <li><i>Result Display:</i> The results of the game are displayed for each player (won, lost, busted, or tied) and their updated chip balance, as well as the dealer's results</li>
            </ul>
            
            <style>
                .image-container_game_play {
                    width: 52vw; /* Adjust the width as needed */
                    height: 30vw; /* Adjust the height as needed */
                    margin: auto; /* Center the container */
                    display: block; /* Ensure the container is a block-level element */
                }
    
                .image-container_game_play img {
                    width: 100%;
                    height: 100%;
                    object-fit: cover; /* Resize the image to cover the container */
                    object-position: 40% 35%; /* Center the image within the container */
                }
            </style>
            <style>
                .image-container_terminal {
                    width: 35vw; /* Adjust the width as needed */
                    height: 37vw; /* Adjust the height as needed */
                    margin: auto; /* Center the container */
                    display: block; /* Ensure the container is a block-level element */
                }

                .image-container_terminal img {
                    width: 100%;
                    height: 100%;
                    object-fit: cover; /* Resize the image to cover the container */
                    object-position: 40% 35%; /* Center the image within the container */
                }
            </style>
            <div class="image-container_game_play" style="text-align:center;">
                <img src="pics/plan_page.jpg" alt="plan page with chips">
            </div>
            <br>
            <p style="text-align: left;padding: 0px 30px;">
                The image above displays the main game interface. At the bottom are UI elements representing chips, incrementing/decrementing options, and hitting/standing options. The empty section is where each player's cards will be laid out. The left side shows the most likely next card value with their respective percentages (based on the simulations run). The right side indicates that the game is running on 12,000,000 simulations, with a minimum bet of $3 and a maximum bet of $1000. It also displays the win probability and tie probability (based on the simulations run). The top middle section shows where the dealer’s cards will be laid out.
            </p>
            <br>
            <div class="image-container_game_play" style="text-align:center;">
                <img src="pics/one_player.jpg" alt="one player simulation">
            </div>
            <br>
            <p style="text-align: left;padding: 0px 30px;">
                This here shows an example of 1 player playing against the dealer. They bet $100 with their starting balance of $1000. They started with a 3 and a Q (total of 13) where the most likely next card values are shown, with a win probability of 34.47% and a tie probability of 4.05%. The player decides to hit and gets an 8 as the next card value (which happens to be outside the next most likely card value drawn). 
            </p>
            <br>
            <div class="image-container_game_play" style="text-align:center;">
                <img src="pics/one_player_with_suggestion.jpg" alt="one player simulation with suggestion on">
            </div>
            <br>
            <p style="text-align: left;padding: 0px 30px;">
                Since this adds up to 21, the most likely next card values all go to 0 since it's recommended to stand now that you are guaranteed to win (since the dealer doesn't have Blackjack). The win probability reflects this as it shoots up to 91.37%, with a 6.96% tie probability.     
            </p>
            <br>
            <div class="image-container_game_play" style="text-align:center;">
                <img src="pics/one_player_won.jpg" alt="one player simulation won">
            </div>
            <br>
            <p style="text-align: left;padding: 0px 30px;">
                Now that the player has stood and there are no other players, the hidden card of the dealer is now displayed (3 of clubs) as well as their remaining cards drawn. This adds up to 17, and since the player got 21, they won $100 as shown in the black box displayed over their cards.    
            </p>
            <br>
            <div class="image-container_game_play" style="text-align:center;">
                <img src="pics/one_player_another_round.jpg" alt="one player simulation another round">
            </div>
            <br>
            <p style="text-align: left;padding: 0px 30px;">
                This shows the gameplay of the same user playing another round (indicated as balance starts off with adjusted winnings from the first round of +$100). This also demonstrates a tie scenario, where the player's cards, which add up to 18 as seen on the left before the player stands, equal the value of the dealer's cards as seen on the right.    
            </p>
            <br>
            <div class="image-container_terminal" style="text-align:center;">
                <img src="pics/terminal.jpg" alt="terminal input">
            </div>
            <br>
            <p style="text-align: left;padding: 0px 30px;">
                This is an example of the interface the user types into during the gameplay. It starts from the main menu screen, where they are prompted to advance to the game screen by clicking “s”. Then they are prompted to enter the number of players (1-4). The top half part of this screen relates to 1 player simulation. Once the results are displayed, the user is prompted whether they want to play again with the same players, restart with new players, or quit. The bottom half of the screen corresponds to the next section where a player plays another round.   
            </p>
            <br>
            <div class="image-container_game_play" style="text-align:center;">
                <img src="pics/three_playes_dealer_busted.jpg" alt="three players are playing and the dealer busted">
            </div>
            <br>
            <p style="text-align: left;padding: 0px 30px;">
                This shows gameplay of 3 players, where the dealer busted so players 1 (total of 19) and 3 (total of 17) won, but player 2 (total of 22) had busted.   
            </p>
            <br>
            <div class="image-container_game_play" style="text-align:center;">
                <img src="pics/four_players_fourth_playerBJ.jpg" alt="four players are playing and the fourth player hit BlackJack">
            </div>
            <br>
            <div class="image-container_game_play" style="text-align:center;">
                <img src="pics/four_players_dealerBJ.jpg" alt="four players are playing and the dealer hit BlackJack">
            </div>
            <br>
            <p style="text-align: left;padding: 0px 30px;">
                This shows the gameplay of 4 players, where player 4 looks like they are going to win since they hit Blackjack (10 of hearts and Ace of diamonds, where Ace is the value of 11). However, since the dealer hit Blackjack everyone will automatically lose (no players can draw further cards), except player 4 who ties with the dealer.    
            </p>
        </div>

    <hr id='result'>
      <div>
            <h2 style="text-align:left; padding: 0px 26px;">Results</h2>

            <div style="text-align:center;">
                <img src="pics/chip_planner.jpg" alt="screenshot of chip planner">
            </div>
            <br>
            <p style="text-align: left;padding: 0px 30px;">
                As the chip planner image indicates, the major limiting factor on the FPGA was the ALMs available. The project heavily relied on registers to keep track of temporary results across all internal simulations and higher bit width registers within generated statements to account for the multiple internal simulations run within a parallel block. The final ALM usage amounted to 97% usage with an additional parallel block pushing it to near 103% usage. Memory, on the other hand, was abundant as the project only utilized 34% of available memory despite supporting a major central OnChip-SRAM and multiple duplicate M10K blocks for each parallel block to easily manipulate card values. 
            </p>
            <div style="text-align:center;">
                <img src="pics/win_prob_converge.png" alt="win probability convergence">
                <img src="pics/tie_prob_convergence.png" alt="tie probability convergence">
                <img src="pics/loss_prob_convergence.png" alt="loss probability convergence">
            </div>
            <p style="text-align: left;padding: 0px 30px;">
                The plots above display the convergence plots through multiple runs. The goal remained to find out what simulation count the probabilities would start to converge towards a steady value considering the same hand for the player and dealer simulation-to-simulation. The observed result was that between the 450,000 and 600,000 simulations, the probability for all measurements - loss, wins, and ties - started to plateau and converge to a singular value. As the plots indicate, after the point mentioned above, the probabilities are largely stationary, forming a near-straight line with only minor differences in the decimal point of the percentages. 
            </p>
      </div>

    <hr id='conclusion & future work'>

    <div>
        <h2 style="text-align:left; padding: 0px 26px;">Conclusions & Future Work</h2>
        <p style="text-align: left;padding: 0px 30px;">
            Our design meets the expectations set in the proposal. It was a great learning opportunity to explore more about On-Chip SRAMs, random number generation, Monte Carlo methods, and FPGA+HPS integration.  

            A future improvement our group would like to implement would be to optimize the state machine. Currently, our state machine utilizes 13 states, though nearly 4 to 5 states function as read buffer states from the local M10k memory. An improvement would be to experiment with single cycle reads, especially since only 2 On-Chip SRAMs are being shared between the ARM and FPGA. 

            A second improvement our group would like to incorporate is reducing the dependence on registers. As mentioned prior in the report, the biggest obstacle in this project was the ALM space constraints. However, moving more data to memory locations that can be more easily manipulated per internal simulation will include a greater number of parallel blocks on the Verilog side. Since only 34% of the memory is utilized, this potential improvement certainly makes the incorporation of this suggested improvement possible. 

        </p>
    </div>

    <hr id ='appendix'>

        <div>
            <h2 style="text-align:left; padding: 0px 26px;">Appendix A</h2>
            <p style="text-align: left;padding: 0px 30px;">
                The group approves this report for inclusion on the course website.
                The group approves the video for inclusion on the course youtube channel.
            </p>
        </div>

        <div>
            <h2 style="text-align:left; padding: 0px 26px;">Additional Appendices</h2>
            <a href="/BlackJack_Verilog_C.zip" download="5760Final_Blackjack_code.zip" style="text-align:left; padding: 0px 30px;">Download BlackJack_Using_MonteCarlo code ZIP File</a>
        </div>